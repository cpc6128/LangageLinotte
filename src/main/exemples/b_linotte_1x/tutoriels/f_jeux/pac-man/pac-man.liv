Pac-man :
("Version 	: 0.1")
("Auteurs	: cpc6128,zamirh")
("Date		: novembre 2010")
	Espèces :
		initx & inity & posx & posy & posinitx & posinity & score & niveau :: nombre
		init & télétransporté & malade & mangé :: drapeau <- faux
		l'espèce partie contient score, niveau
		l'espèce personnage hérite de praxinoscope et contient  posx, posy, posinitx, posinity, init, initx, inity, télétransporté, malade, mangé
	Grands Rôles :
		gGameOver :: graffiti, texte = "GAME OVER", position = 100000, taille = 20, x = 150, y = 250, couleur = "rouge"
		icônelifes1 :: graphique, image = "pac1.png", x = 380, y = 475, position = 100000
		icônelifes2 :: graphique, image = "pac1.png", x = 400, y = 475, position = 100000
		lifes :: graffiti, texte = "LIFES", couleur = "jaune", taille = 10, position = 100000, x = 300, y = 490
		Titre Score :: graffiti, texte = "SCORE", couleur = "jaune", taille = 10, position = 100000, x = 30, y = 490
		gScore :: graffiti, texte = "0", couleur = "jaune", taille = 10, position = 100000, x = 130, y = 490
		vie :: nombre <- 3
		vitesse :: nombre <- 10
		taille :: nombre <- 15
		x :: nombre <- 50
		y :: nombre <- 30
		pacpacpac :: nombre <- 0
		image jeu :: toile, couleur = "noir", largeur = 500, hauteur = 500
		fond :: graphique,y = 150, image = "logo.png", position = 3,...
            transparence = 10
		quitter :: nombre <- 0
		pacman :: personnage, position = 1, ...
            image0 =  "pac1.png", ...
            image1 =  "pac2.png"
		fantome :: personnage, position = 1, ...
            image0 =  "fantome1.png", ...
            image1 =  "fantome2.png", ...
            image2 =  "fantome3.png", ...
            image3 =  "fantome4.png", ...
            image4 =  "fantome5.png", ...
            image5 =  "fantome6.png", ...
            image6 =  "fantome7.png"
		fantome1 :: personnage, position = 1, ...
            image0 =  "fantome1.png", ...
            image1 =  "fantome2.png", ...
            image2 =  "fantome3.png", ...
            image3 =  "fantome4.png", ...
            image4 =  "fantome5.png", ...
            image5 =  "fantome6.png", ...
            image6 =  "fantome7.png"
		fantome2 :: personnage, position = 1, ...
            image0 =  "fantome1.png", ...
            image1 =  "fantome2.png", ...
            image2 =  "fantome3.png", ...
            image3 =  "fantome4.png", ...
            image4 =  "fantome5.png", ...
            image5 =  "fantome6.png", ...
            image6 =  "fantome7.png"
		fantome3 :: personnage, position = 1, ...
            image0 =  "fantome1.png", ...
            image1 =  "fantome2.png", ...
            image2 =  "fantome3.png", ...
            image3 =  "fantome4.png", ...
            image4 =  "fantome5.png", ...
            image5 =  "fantome6.png", ...
            image6 =  "fantome7.png"
		niveau courant :: casier de nombre vide
		niveau courant image :: casier de graphique vide
		direction :: texte vide
		touches :: casier de texte <- "gauche", "droite", "haut", "bas"
        ("Pièces :")
		a :: nombre <- 27
		b :: nombre <- -27
		c :: nombre <- 10
		d :: nombre <- 11
		e :: nombre <- 12
		f :: nombre <- 13
		g :: nombre <- 14
		sensh :: casier de texte <- "gauche", "droite"
		sensv :: casier de texte <- "haut", "bas"
		boules :: casier de graphique vide

Décor :
	Rôles :
		§page de garde :: toile
		§image0 :: graphique, image = "vide.png"
		§image1 :: graphique, image = "diamant.png"
		§image2 :: graphique, image = "vide.png"
		§image3 :: graphique, image = "pack.png"
		§image4 :: graphique, image = "mur_h.png"
		§image5 :: graphique, image = "mur_v.png"
		§image6 :: graphique, image = "mur_gh.png"
		§image7 :: graphique, image = "mur_dh.png"
		§image8 :: graphique, image = "mur_gb.png"
		§image9 :: graphique, image = "mur_db.png"
		§image10 :: graphique, image = "vide.png"
		pieces :: casier de graphique <- image0, image1, ...
            image2, image3, image4, image5, image6, image7, image8, image9, ...
             image10, image10, image10, image10, image10
		§niveau1 :: casier de nombre <- 28, 31 ("largeur X hauteur") , ...
            6,4,4,4,4,4,4,4,4,4,4,4,4,7,6,4,4,4,4,4,4,4,4,4,4,4,4,7, ...
            5,1,1,1,1,1,1,1,1,1,1,1,1,5,5,1,1,1,1,1,1,1,1,1,1,1,1,5, ...
            5,1,6,4,4,7,1,6,4,4,4,7,1,5,5,1,6,4,4,4,7,1,6,4,4,7,1,5, ...
            5,3,5,0,0,5,1,5,0,0,0,5,1,5,5,1,5,0,0,0,5,1,5,0,0,5,3,5, ...
            5,1,8,4,4,9,1,8,4,4,4,9,1,8,9,1,8,4,4,4,9,1,8,4,4,9,1,5, ...
            5,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,5, ...
            5,1,6,4,4,7,1,6,7,1,6,4,4,4,4,4,4,7,1,6,7,1,6,4,4,7,1,5, ...
            5,1,8,4,4,9,1,5,5,1,8,4,4,7,6,4,4,9,1,5,5,1,8,4,4,9,1,5, ...
            5,1,1,1,1,1,1,5,5,1,1,1,1,5,5,1,1,1,1,5,5,1,1,1,1,1,1,5, ...
            8,4,4,4,4,7,1,5,8,4,4,7,0,5,5,0,6,4,4,9,5,1,6,4,4,4,4,9, ...
            0,0,0,0,0,5,1,5,6,4,4,9,0,8,9,0,8,4,4,7,5,1,5,0,0,0,0,0, ...
            0,0,0,0,0,5,1,5,5,0,0,0,0,0,0,0,0,0,0,5,5,1,5,0,0,0,0,0, ...
            0,0,0,0,0,5,1,5,5,0,6,4,4,g,g,4,4,7,0,5,5,1,5,0,0,0,0,0, ...
            4,4,4,4,4,9,1,8,9,0,5,0,0,g,g,0,0,5,0,8,9,1,8,4,4,4,4,4, ...
            a,0,0,0,0,0,1,0,0,0,5,0,0,d,e,0,0,5,0,0,0,1,0,0,0,0,0,b, ...
            4,4,4,4,4,7,1,6,7,0,5,0,0,c,f, 0,0,5,0,6,7,1,6,4,4,4,4,4, ...
            0,0,0,0,0,5,1,5,5,0,5,0,0,0,0,0,0,5,0,5,5,1,5,0,0,0,0,0, ...
            0,0,0,0,0,5,1,5,5,0,8,4,4,4,4,4,4,9,0,5,5,1,5,0,0,0,0,0, ...
            0,0,0,0,0,5,1,5,5,0,0,0,0,0,0,0,0,0,0,5,5,1,5,0,0,0,0,0, ...
            6,4,4,4,4,9,1,8,9,0,4,4,4,7,6,4,4,4,0,8,9,1,8,4,4,4,4,7, ...
            5,1,1,1,1,1,1,1,1,1,1,1,1,5,5,1,1,1,1,1,1,1,1,1,1,1,1,5, ...
            5,1,6,4,4,7,1,6,4,4,4,7,1,5,5,1,6,4,4,4,7,1,6,4,4,7,1,5, ...
            5,1,8,4,7,5,1,8,4,4,4,9,1,8,9,1,8,4,4,4,9,1,5,6,4,9,1,5, ...
            5,3,1,1,5,5,1,1,1,1,1,1,1,2,0,1,1,1,1,1,1,1,5,5,1,1,3,5, ...
            8,4,7,1,5,5,1,6,7,1,6,4,4,4,4,4,4,7,1,6,7,1,5,5,1,6,4,9, ...
            6,4,9,1,8,9,1,5,5,1,8,4,4,7,6,4,4,9,1,5,5,1,8,9,1,8,4,7, ...
            5,1,1,1,1,1,1,5,5,1,1,1,1,5,5,1,1,1,1,5,5,1,1,1,1,1,1,5, ...
            5,1,6,4,4,4,4,9,8,4,4,7,1,5,5,1,6,4,4,9,8,4,4,4,4,7,1,5, ...
            5,1,8,4,4,4,4,4,4,4,4,9,1,8,9,1,8,4,4,4,4,4,4,4,4,9,1,5, ...
            5,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,5, ...
            8,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,9
		niveaux :: casier de casier <- niveau1
            ("Acteurs du jeu")
		jeu :: partie,niveau = 0, score = 0
	Actions :
		quitter = 0
            ("Initialiser les moteurs :")
		appelle gestion touches
		parcours affichage niveau avec niveaux{niveau@jeu}
        ("on commence le jeu :")
		projette fond
		projette lifes
		projette icônelifes1
		projette icônelifes2
		projette Titre Score & gScore
		projette pacman
		projette fantome & fantome1 & fantome2 & fantome3
		appelle animation pacman
		appelle animation fantome
		appelle moteur pacman
		appelle moteur fantome avec fantome
		appelle moteur fantome avec fantome1
		appelle moteur fantome avec fantome2
		appelle moteur fantome avec fantome3
		appelle clignotement
		parcours initialisation des personnages
        ("boucle infinie")
		tant que vrai, lis
			attends 1 seconde
		ferme
		termine

Affichage niveau :
	Rôles :
		*niveau :: casier de nombre
		largeur :: nombre <- niveau{0}
		§largeur temporaire :: nombre
		hauteur :: nombre <- niveau{1}
		§hauteur temporaire :: nombre
		§position :: nombre <- 2
		image fond :: rectangle, couleur = "noir", plein = "oui", largeur = largeur * taille, hauteur = hauteur * taille
	Actions :
		vide niveau courant
		efface la toile
		projette image jeu
		parcours calculer x et y avec largeur, hauteur,largeur@image fond, hauteur@image fond
		x@image fond = x
		y@image fond = y
		("On boucle est affiche le niveau :")
		("affiche niveau")
		projette image fond
		bug :: nombre
		pour chaque hauteur, lis
			largeur temporaire = 0
			pour chaque largeur, lis
				si ((niveau{position}) < 20) et ((niveau{position}) > 0) alors lis
					ajoute affichage image (niveau{position}, largeur temporaire, hauteur temporaire) dans niveau courant image
				ferme
				sinon, ajoute affichage image (0, largeur temporaire, hauteur temporaire) dans niveau courant image
				bug =  niveau{position}
				si  bug == c alors lis
					bug = g
				ferme
				sinon, si  bug == d alors lis
					bug = g
				ferme
				sinon, si  bug == e alors lis
					bug = g
				ferme
				sinon, si  bug == f alors lis
					bug = g
				ferme
				ajoute #bug dans niveau courant
				position = position + 1
				largeur temporaire = largeur temporaire + 1
			ferme
			hauteur temporaire = hauteur temporaire + 1
		ferme
		reviens

Affichage image :
	Rôles :
		*type :: nombre
		*largeur :: nombre
		*hauteur :: nombre
		§image :: casier de graphique
		pieces :: casier de graphique
	Actions :
		si type == 2 alors lis
			x@pacman = x+largeur*taille
			y@pacman = y+hauteur*taille
			posx@pacman = largeur
			posy@pacman = hauteur
			posinitx@pacman = largeur
			posinity@pacman = hauteur
			initx@pacman = x@pacman
			inity@pacman = y@pacman
		ferme
		sinon, si type == c alors lis
			x@fantome = x+largeur*taille
			y@fantome = y+hauteur*taille
			posx@fantome = largeur
			posy@fantome = hauteur
			posinitx@fantome = largeur
			posinity@fantome = hauteur
			initx@fantome = x@fantome
			inity@fantome = y@fantome
		ferme
		sinon, si type == d alors lis
			x@fantome1 = x+largeur*taille
			y@fantome1 = y+hauteur*taille
			posx@fantome1 = largeur
			posy@fantome1 = hauteur
			posinitx@fantome1 = largeur
			posinity@fantome1 = hauteur
			initx@fantome1 = x@fantome1
			inity@fantome1 = y@fantome1
		ferme
		sinon, si type == e alors lis
			x@fantome2 = x+largeur*taille
			y@fantome2 = y+hauteur*taille
			posx@fantome2 = largeur
			posy@fantome2 = hauteur
			posinitx@fantome2 = largeur
			posinity@fantome2 = hauteur
			initx@fantome2 = x@fantome2
			inity@fantome2 = y@fantome2
		ferme
		sinon, si type == f alors lis
			x@fantome3 = x+largeur*taille
			y@fantome3 = y+hauteur*taille
			posx@fantome3 = largeur
			posy@fantome3 = hauteur
			posinitx@fantome3 = largeur
			posinity@fantome3 = hauteur
			initx@fantome3 = x@fantome3
			inity@fantome3 = y@fantome3
		ferme
		ajoute #(pieces {type})  dans image
		si type == 3 alors lis
			ajoute image{0} dans boules
		ferme
		x@(image{0}) = x+largeur*taille
		y@(image{0}) = y+hauteur*taille
		projette image{0}
		retourne image{0}

Calculer X et Y :
	Rôles :
		*largeur :: nombre
		*hauteur :: nombre
		*delta l :: nombre
		*delta h :: nombre
	Actions :
		x = ( largeur@image jeu - largeur ) / 2 - delta l / 2
		y = ( hauteur@image jeu - hauteur) / 2 - delta h / 2
		reviens

Gestion touches :
	Rôles :
		§t :: texte
		§i :: nombre
	Actions :
		Vide les touches
		Tant que vrai, lis
			temporise
			t = touche
			cherche i, la position de t dans touches
			si i != 0 alors direction = t
		Ferme

Moteur fantome :
	Rôles :
		*monstre :: personnage
		§sens :: texte <- "haut"
		§sens temporaire :: texte
		§dé :: nombre
		§positionx :: texte
		§positiony :: texte
		largeur & hauteur :: nombre
		§temps :: nombre
	Actions :
		Tant que vrai, lis
			si init@monstre alors lis
				posx@monstre = posinitx@monstre
				posy@monstre = posinity@monstre
				x@monstre = initx@monstre
				y@monstre = inity@monstre
				init@monstre = faux
				malade@monstre = faux
				mangé@monstre = faux
				sens = "haut"
			ferme
			("Gestion de la vitesse")
			si malade@monstre alors temps = vitesse *2
			sinon, temps = vitesse
			Si sens == "haut" alors lis
				si vérifier position fantome(posx@monstre,posy@monstre-1) alors lis
					pour chaque 15, lis
						y@monstre = y@monstre - 1
						("Est-ce que j'ai de quoi manger ?")
						Parcours tester contacte avec monstre
						attends temps milliseconde
					ferme
					posy@monstre = posy@monstre - 1
				ferme
				sinon, lis
					sens temporaire = sens
					vide sens
				ferme
			Ferme
			Si sens == "bas" alors lis
				si vérifier position fantome(posx@monstre,posy@monstre+1) alors lis
					("Il ne doit pas revenir dans la boite")
					si (niveau courant{(posx@monstre) + largeur * (posy@monstre)}) diff g alors lis
						pour chaque 15, lis
							y@monstre = y@monstre + 1
							("Est-ce que j'ai de quoi manger ?")
							Parcours tester contacte avec monstre
							attends temps milliseconde
						ferme
						posy@monstre = posy@monstre + 1
					ferme
					sinon, sens = "haut"
				ferme
				sinon, lis
					sens temporaire = sens
					vide sens
				ferme
			Ferme
			Si sens == "droite" alors lis
				si vérifier position fantome(posx@monstre-1,posy@monstre) alors lis
					pour chaque 15, lis
						x@monstre = x@monstre - 1
						("Est-ce que j'ai de quoi manger ?")
						Parcours tester contacte avec monstre
						attends temps milliseconde
					ferme
					posx@monstre = posx@monstre - 1
				ferme
				sinon, lis
					sens temporaire = sens
					vide sens
				ferme
			Ferme
			Si sens == "gauche" alors lis
				si vérifier position fantome(posx@monstre+1,posy@monstre) alors lis
					pour chaque 15, lis
						x@monstre = x@monstre + 1
						("Est-ce que j'ai de quoi manger ?")
						Parcours tester contacte avec monstre
						attends temps milliseconde
					ferme
					posx@monstre = posx@monstre + 1
				ferme
				sinon, lis
					sens temporaire = sens
					vide sens
				ferme
			Ferme
			si sens == "" alors lis
				("Il est face à un mur")
				sens = nouvelle direction fantome (sens temporaire)
			ferme
			sinon, lis
				si niveau courant{(posx@monstre) + largeur * (posy@monstre)} est différent de g alors lis
				("At-il un mur sur son côté ?")
					Dé = 1
					si dé == 1 alors lis
						si malade@monstre est faux alors lis
							("On ne tourne que si on va dans le sens de pacman.... miam, j'ai faim !")
							si posx@monstre est plus petit que posx@pacman alors positionx = "gauche"
							si posx@monstre est plus grand que posx@pacman alors positionx = "droite"
							si posy@monstre est plus petit que posy@pacman alors positiony = "bas"
							si posy@monstre est plus grand que posy@pacman alors positiony = "haut"
						ferme
						sinon, si mangé@monstre alors lis
							("Chui malade, je rentre !")
							si posx@monstre est plus petit que largeur / 2 alors positionx = "gauche"
							si posx@monstre est plus grand que largeur / 2 alors positionx = "droite"
							si posy@monstre est plus petit que hauteur / 2 alors positiony = "bas"
							si posy@monstre est plus grand que hauteur / 2 alors positiony = "haut"
						ferme
						sinon, lis
							("Sauve qui peut !")
							si posx@monstre est plus petit que posx@pacman alors positionx = "droite"
							si posx@monstre est plus grand que posx@pacman alors positionx = "gauche"
							si posy@monstre est plus petit que posy@pacman alors positiony = "haut"
							si posy@monstre est plus grand que posy@pacman alors positiony = "bas"
						ferme
						si sens == "gauche" alors lis
							("on regarde en haut")
							si vérifier position fantome(posx@monstre,posy@monstre-1) alors lis
								si positiony == "haut" alors sens = "haut"
							ferme
							sinon, lis
								("on regarde en bas")
								si vérifier position fantome(posx@monstre,posy@monstre+1) alors lis
									si positiony == "bas" alors sens = "bas"
								ferme
							ferme
						ferme
						sinon, si sens == "bas" alors lis
							("on regarde à droite")
							si vérifier position fantome(posx@monstre -1,posy@monstre) alors lis
								si positionx == "droite" alors sens = "droite"
							ferme
							sinon, lis
								("on regarde à gauche")
								si vérifier position fantome(posx@monstre +1,posy@monstre) alors lis
									si positionx == "gauche" alors sens = "gauche"
								ferme
							ferme
						ferme
						sinon, si sens == "droite" alors lis
                        ("on regarde en haut")
							si vérifier position fantome(posx@monstre,posy@monstre-1) alors lis
								si positiony == "haut" alors sens = "haut"
							ferme
							sinon, lis
                            ("on regarde en bas")
								si vérifier position fantome(posx@monstre,posy@monstre+1) alors lis
									si positiony == "bas" alors sens = "bas"
								ferme
							ferme
						ferme
						sinon, si sens == "haut" alors lis
                        ("on regarde à droite")
							si vérifier position fantome(posx@monstre -1,posy@monstre) alors lis
								si positionx == "droite" alors sens = "droite"
							ferme
							sinon, lis
                            ("on regarde à gauche")
								si vérifier position fantome(posx@monstre +1,posy@monstre) alors lis
									si positionx == "gauche" alors sens = "gauche"
								ferme
							ferme
						ferme
					ferme
				ferme
			ferme
			attends vitesse milliseconde
			parcours télétransportation avec posx@monstre,posy@monstre,monstre
		Ferme

Nouvelle direction fantome :
	Rôles :
		*sens :: texte
		§dé :: nombre <- 2
		§t :: nombre
	Actions :
		mélange dé
		cherche t, la position de sens dans sensv
		si t != 0 alors lis
			sens = sensh {dé}
		ferme
		sinon, sens = sensv {dé}
		Retourne sens

Moteur pacman :
	Rôles :
		§temp :: texte
	Actions :
		Tant que vrai, lis
			si init@pacman alors lis
				posx@pacman = posinitx@pacman
				posy@pacman = posinity@pacman
				x@pacman = initx@pacman
				y@pacman = inity@pacman
				init@pacman = faux
			ferme
			temp = direction
			Si temp == "gauche" alors lis
				si vérifier position(posx@pacman-1,posy@pacman) alors lis
					angle@pacman = 0
					pour chaque 15, lis
						x@pacman = x@pacman - 1
						attends vitesse milliseconde
					ferme
					posx@pacman = posx@pacman - 1
				ferme
			Ferme
			Sinon, si temp == "droite" alors lis
				si vérifier position(posx@pacman+1,posy@pacman) alors lis
					angle@pacman = 180
					pour chaque 15, lis
						x@pacman = x@pacman + 1
						attends vitesse milliseconde
					ferme
					posx@pacman = posx@pacman + 1
				ferme
			Ferme
			Sinon, si temp == "bas" alors lis
				si vérifier position(posx@pacman,posy@pacman+1) alors lis
					angle@pacman = 270
					pour chaque 15, lis
						y@pacman = y@pacman + 1
						attends vitesse milliseconde
					ferme
					posy@pacman = posy@pacman + 1
				Ferme
			Ferme
			Sinon, si temp == "haut" alors lis
				si vérifier position(posx@pacman,posy@pacman-1) alors lis
					angle@pacman = 90
					pour chaque 15, lis
						y@pacman = y@pacman - 1
						attends vitesse milliseconde
					ferme
					posy@pacman = posy@pacman - 1
				Ferme
			Ferme
			attends vitesse milliseconde
			parcours télétransportation avec posx@pacman,posy@pacman,pacman
		Ferme

Animation pacman :
	Actions :
		Tant que vrai, lis
			Pour chaque 2, lis
				Attends vitesse * 3 * 10 millisecondes
				trame@pacman = joker
			Ferme
		Ferme

Animation fantome :
	Actions :
		Tant que vrai, lis
			Pour chaque 3, lis
				Attends vitesse * 50 millisecondes
				parcours change apparance avec fantome, joker
				parcours change apparance avec fantome1, joker
				parcours change apparance avec fantome2, joker
				parcours change apparance avec fantome3, joker
			Ferme
		Ferme

Change apparance :
	Rôles :
		*monstre :: personnage
		*trame :: nombre
	Actions :
		si mangé@monstre alors trame@monstre = 6
		sinon, si malade@monstre alors trame@monstre = trame + 3
		sinon, trame@monstre = trame
		Reviens

Télétransportation :
	Rôles :
		*tx :: nombre
		*ty :: nombre
		*spock :: personnage
		largeur :: nombre
		§type :: nombre <- niveau courant{tx + largeur * ty}
	Actions :
		si  type > 20 alors lis
            ("Le type correspond au delta")
            ("angle@spock = 180")
			télétransporté@spock = vrai
			pour chaque type, lis
				pour chaque 15, lis
					x@spock = x@spock + 1
					attends vitesse / 10 milliseconde
				ferme
				posx@spock = posx@spock + 1
			ferme
			télétransporté@spock = faux
		ferme
		si  type < 0 alors lis
            ("Le type correspond au delta")
            ("angle@spock = 0")
			télétransporté@spock = vrai
			pour chaque abs(type), lis
				pour chaque 15, lis
					x@spock = x@spock - 1
					attends vitesse / 10 milliseconde
				ferme
				posx@spock = posx@spock - 1
			ferme
			télétransporté@spock = faux
		ferme
		Reviens

Vérifier position :
	Rôles :
		*tx :: nombre
		*ty :: nombre
		largeur :: nombre
		§type :: nombre <- niveau courant{tx + largeur * ty}
	Actions :
		si type == 1 alors lis
            ("BOGUE Linotte 1.2.4, la ligne suivante ne marche pas si on n'utilise
            pas la variable bogue (cf plus haut). 
            Le codeur de Linotte programme comme ses pieds !")
			niveau courant{tx + largeur * ty} = 0
			si transparence@(niveau courant image{tx + largeur * ty}) est différent de 0 alors lis
				appelle effacer image avec niveau courant image{tx + largeur * ty}
			ferme
			parcours incrémentescore avec 1
			retourne vrai
		ferme
		sinon,si type == 3 alors lis
			niveau courant{tx + largeur * ty} = 0
			Ôte niveau courant image{tx + largeur * ty} de boules
			Efface niveau courant image{tx + largeur * ty}
			appelle pac pac pac
			parcours incrémentescore avec 10
			retourne vrai
		ferme
		sinon, si ((type == 2)) ou (type == 0)  alors lis
			retourne vrai
		ferme
		sinon, si  (type > 20) ou (type < 0) alors lis
			retourne vrai
		ferme
		sinon, lis
			direction = ""
			retourne faux
		ferme

Vérifier position fantome :
	Rôles :
		*tx :: nombre
		*ty :: nombre
		largeur :: nombre
		§type :: nombre <- niveau courant{tx + largeur * ty}
	Actions :
		si type == 3 alors lis
			retourne vrai
		ferme
		sinon, si ((type == 2)) ou (type == 0) alors lis
			retourne vrai
		ferme
		sinon, si  (type > 20) ou (type < 0) alors lis
			retourne vrai
		ferme
		sinon, si  type == 1 alors lis
			retourne vrai
		ferme
		sinon, si  type == g alors lis
			retourne vrai
		ferme
		sinon, lis
			retourne faux
		ferme

Effacer image :
	Rôles :
		*g :: graphique
		§boucle :: nombre <- transparence@g
		§i :: nombre
	Actions :
		Pour i de boucle à 0 , lis
			attends vitesse  milliseconde
			transparence@g = i
		Ferme
		reviens

Tester contacte :
	Rôles :
		*monstre :: personnage
	Actions :
		si monstre est en collision avec pacman alors lis
			si posy@monstre est égal à posy@pacman alors lis
				si posx@monstre est égal à posx@pacman alors lis
					si télétransporté@pacman est faux alors lis
						si malade@monstre est faux alors lis
							soustrais 1 dans vie
							va vers vies
						ferme
						sinon, lis
							si mangé@monstre est faux alors lis
								parcours incrémentescore avec 30
								mangé@monstre = vrai
							ferme
						ferme
					ferme
				ferme
			ferme
		ferme
		Reviens

Vies :
	Actions :
		si vie est égale à 0 alors parcours game over
		si vie est égale à 2 alors lis
			efface icônelifes2
			va vers respawn
		ferme
		si vie == 1 alors lis
			efface icônelifes1
			va vers respawn
		ferme

Respawn :
	Actions :
		init@pacman = vrai
		init@fantome = vrai
		init@fantome1 = vrai
		init@fantome2 = vrai
		init@fantome3 = vrai
		va vers moteur fantome

Game Over :
	Actions :
		Projette gGameOver
		Attends 3 secondes
		Termine

Clignotement :
	Rôles :
		§boucle :: nombre vide
	Actions :
		Tant que vrai, lis
			pour chaque boules, lis
				boucle = boucle + 2
				transparence de joker = abs (cos boucle)  * 100
				attends vitesse millisecondes
			ferme
		Ferme
		Reviens

Pac pac pac :
	Rôles :
		§marqueur :: nombre
	Actions :
		pacpacpac = pacpacpac + 1
		marqueur = pacpacpac
		malade@fantome = vrai
		malade@fantome1 = vrai
		malade@fantome2 = vrai
		malade@fantome3 = vrai
		attends 20 secondes
		si pacpacpac == marqueur alors lis
			parcours initialisation des personnages
		ferme
		Reviens

Initialisation des personnages :
	Actions :
		malade@fantome = faux
		malade@fantome1 = faux
		malade@fantome2 = faux
		malade@fantome3 = faux
		mangé@fantome = faux
		mangé@fantome1 = faux
		mangé@fantome2 = faux
		mangé@fantome3 = faux
		Reviens

Incrémentescore :
	Rôles :
		*val :: nombre
		jeu :: partie
	Actions :
		score@jeu = score@jeu + val
		texte@gscore = score@jeu
		Reviens
