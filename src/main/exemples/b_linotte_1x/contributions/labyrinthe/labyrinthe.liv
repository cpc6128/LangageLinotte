Livre : Labyrinthe
("Spécification 1.2")
("Auteur : $imon")
("http://langagelinotte.free.fr/punbb/viewtopic.php?id=300")
	espèces :
		orientation est un nombre  ("0:droite,  1:haut,  2:gauche,  3:bas ")
		ordre est un nombre valant -1
		block est un nombre valant 1 ("0:vide, 1:mur ")
		l'espèce case hérite de rectangle et contient une orientation, un ordre, un block
	grands rôles:
		DEBOGAGE est un nombre valant 0
(" pour comprendre comment marche le livre, vous pouvez mettre la valeur de DEBOGAGE à 1 ")

Paragraphe : p1
	Rôles :
		balle est un cercle, taille vaut 1, rayon vaut 4, couleur vaut "rouge", plein vaut "oui", position vaut 120
		labyrinthe est un casier de case
		tailleLabyrinthe est un nombre
		tailleCote est un nombre
		txt est un texte
		txt2 est un texte
		fond est une toile, couleur vaut "noir"
		graff est un graffiti, couleur vaut "gris perle"
		case_départ est un nombre
		case_arrivée est un nombre
		continuer est un nombre
		case_lue est un nombre
		n est un nombre
		m est un nombre
		pourcentage est un nombre
		touch est un texte
		alea est un nombre
	Actions :
		efface le tableau
		efface la toile
		vide labyrinthe
		questionne tailleCote sur "Combien de cases en hauteur ? (entre 15 et 100 )"
		si tailleCote est plus petit que 15 alors termine
		si tailleCote est plus grand que 100 alors termine
		tailleLabyrinthe = tailleCote * tailleCote
		largeur de fond = tailleCote * 10
		hauteur de fond = tailleCote * 10
		x de graff = 10
		y de graff = 20
		position de graff = 120
		texte de graff = "0/7-  " + "INITIALISATION..."
		taille de graff = 1 + (tailleCote / 10 )
		projette fond
		projette graff
		si DEBOGAGE est égal à 1 alors ...
"On commence par initialiser les cases" !
		de 0 à (tailleLabyrinthe - 1 ), lis
			concatène "case_" , joker dans txt
			crée txt un acteur case
			hauteur de création = 10
			largeur de création = 10
			si DEBOGAGE est égal à 1 alors couleur de création = "noir"
			plein de création = "oui"
			taille de création = 1
			block de création = 1
			ordre de création = -1
			y de création = (joker mod taillecote) * 10
			x de création = 10 * entier (joker / taillecote)
			si DEBOGAGE est égal à 1 alors projette création
			ajoute création dans labyrinthe
		ferme
		case_départ = tailleCote - 2
		mélange case_départ
		txt = [labyrinthe{ case_départ + 1}]
		si DEBOGAGE est égal à 1 alors couleur de <<txt>> = "rouge"
		projette <<txt>>
		texte de graff = "1/7-  " + "CREATION DU PARCOURS..."
		si DEBOGAGE est égal à 1 alors affiche "Première étape :
nous créons la solution du labyrinthe. Pour cela, nous partons 
de la case rouge puis nous nous déplaceons de manière aléatoire
jusqu'à atteindre le coté droit. nous enregistrons dans chaque
case la position de la case suivante grace à l'acteur orientation.
[ LES CASES PARCOURUES SONT EN MARRON ]"
		continuer = 1
		case_lue = case_départ
		tant que continuer est égal à 1, lis
			txt = [labyrinthe{ case_lue}]
			si DEBOGAGE est égal à 1 alors couleur de <<txt>> = "marron"
			n = 4
			mélange n
			si n est égal à 0 alors lis
				si x de <<txt>> est différent de ( 10 * tailleCote - 10 ) alors lis
					orientation de <<txt>> = n
					case_lue = case_lue + tailleCote
				ferme
			ferme
			si n est égal à 1 alors lis
				si y de <<txt>> est différent de 0 alors lis
					orientation de <<txt>> = n
					case_lue = case_lue - 1
				ferme
			ferme
			si n est égal à 2 alors lis
				si x de <<txt>> est différent de 0 alors lis
					orientation de <<txt>> = n
					case_lue = case_lue - tailleCote
				ferme
			ferme
			si n est égal à 3 alors lis
				si y de <<txt>> est différent de ( 10 * tailleCote - 10 ) alors lis
					orientation de <<txt>> = n
					case_lue = case_lue + 1
				ferme
			ferme
			si x de <<txt>> est égal à ( 10 * tailleCote - 10 ) alors continuer = 0
		ferme
		texte de graff = "2/7-  " + "SUPPRESSIONS CROISEMENTS..."
		si DEBOGAGE est égal à 1 alors affiche "Deuxième étape :
Certaines cases ont été parcourues plusieurs fois.Du coup,
il y a des croisements. Nous voulons que le labrinthe n'aie
qu'une solution. Pour cela nous allons supprimer les croisements.
Cela est fait grace à l'acteur 'orientation', comme une case n'a 
qu'un seul acteur orientation, si elle est parcourue plus d'une
fois, elle ne 'retient' que la direction de la case de la dernière
fois. Tous les croisements sont alors supprimés. Nous en 
profitons aussi pour mémoriser l'ordre de chaque case dans
l'acteur ordre.
[ LES CASES RESTANTES SONT EN GRIS ]"
		continuer = 1
		case_lue = case_départ
		n = -1
		tant que continuer est égal à 1, lis
			n = n + 1
			txt = [labyrinthe{ case_lue}]
			si DEBOGAGE est égal à 1 alors couleur de <<txt>> = "gris"
			ordre de <<txt>> = n
			si x de <<txt>> est égal à ( 10 * tailleCote - 10 ) alors case_arrivée = case_lue
			si orientation de <<txt>> est égal à 0 alors lis
				case_lue = case_lue + tailleCote
			ferme
			si orientation de <<txt>> est égal à 1 alors lis
				case_lue = case_lue -1
			ferme
			si orientation de <<txt>> est égal à 2 alors lis
				case_lue = case_lue - tailleCote
			ferme
			si orientation de <<txt>> est égal à 3 alors lis
				case_lue = case_lue +1
			ferme
			si x de <<txt>> est égal à ( 10 * tailleCote - 10 ) alors continuer = 0
		ferme
		txt = [labyrinthe{ case_arrivée}]
		couleur de <<txt>> = "saumon"
		block de <<txt>> = 0
		texte de graff = "3/7-  " + "SUPPRESSIONS BOUCLES..."
		si DEBOGAGE est égal à 1 alors affiche "Troisième étape :
Sur notre solution, il reste des endroits ou le chemin se dédouble.
Nous allons donc 'simplifier' le chemin. pour chaque case de la solution,
nous allons chercher la case adjacente dont la valeur 'ordre' est la plus 
grande. Nous allons donc 'sauter' les cases intermédiaires qui créeent
les boucles.
[ LES CASES RESTANTES SONT EN BLEU ]"
		continuer = 1
		case_lue = case_départ
		tant que continuer est égal à 1, lis
			m = 0
			txt = [labyrinthe{ case_lue}]
			si DEBOGAGE est égal à 1 alors couleur de <<txt>> = "bleu pétrole"
			si x de <<txt>> est différent de ( 10 * tailleCote - 10 ) alors lis
				n = Case_lue + tailleCote
				txt2 = [labyrinthe{ n}]
				si ordre de <<txt2>> est plus grand que m alors lis
					si orientation de <<txt2>> est différent de 2 alors lis
						m = ordre de <<txt2>>
						orientation de <<txt>> = 0
					ferme
				ferme
			ferme
			si y de <<txt>> est différent de 0 alors lis
				n = case_lue - 1
				txt2 = [labyrinthe{ n}]
				si ordre de <<txt2>> est plus grand que m alors lis
					si orientation de <<txt2>> est différent de 3 alors lis
						m = ordre de <<txt2>>
						orientation de <<txt>> = 1
					ferme
				ferme
			ferme
			si x de <<txt>> est différent de 0 alors lis
				n = case_lue - tailleCote
				txt2 = [labyrinthe{ n}]
				si ordre de <<txt2>> est plus grand que m alors lis
					si orientation de <<txt2>> est différent de 0 alors lis
						m = ordre de <<txt2>>
						orientation de <<txt>> = 2
					ferme
				ferme
			ferme
			si y de <<txt>> est différent de ( 10 * tailleCote - 10 ) alors lis
				n = case_lue + 1
				txt2 = [labyrinthe{ n}]
				si ordre de <<txt2>> est plus grand que m alors lis
					si orientation de <<txt2>> est différent de 1 alors lis
						m = ordre de <<txt2>>
						orientation de <<txt>> = 3
					ferme
				ferme
			ferme
			si orientation de <<txt>> est égal à 0 alors lis
				case_lue = case_lue + tailleCote
			ferme
			si orientation de <<txt>> est égal à 1 alors lis
				case_lue = case_lue -1
			ferme
			si orientation de <<txt>> est égal à 2 alors lis
				case_lue = case_lue - tailleCote
			ferme
			si orientation de <<txt>> est égal à 3 alors lis
				case_lue = case_lue +1
			ferme
			si x de <<txt>> est égal à ( 10 * tailleCote - 10 ) alors continuer = 0
		ferme
		texte de graff = "4/7-  " + "REMISE EN ORDRE..."
		si DEBOGAGE est égal à 1 alors affiche "quatrième étape :
Nous allons mémoriser le nouvel ordre des cases
dans la solution (grace à l'acteur 'ordre' ). Nous
allons mettre à 0 la valeur de l'acteur block pour
chaque case de la solution. l'acteur block sert à
mémoriser les cases 'mur' (1) et les cases 'vides' (0).
[ LES CASES SONT COLOREES EN BLEU CIEL ]"
		continuer = 1
		case_lue = case_départ
		n = -1
		tant que continuer est égal à 1, lis
			n = n + 1
			txt = [labyrinthe{ case_lue}]
			si DEBOGAGE est égal à 1 alors couleur de <<txt>> = "bleu ciel"
			ordre de <<txt>> = n
			si orientation de <<txt>> est égal à 0 alors lis
				case_lue = case_lue + tailleCote
			ferme
			si orientation de <<txt>> est égal à 1 alors lis
				case_lue = case_lue -1
			ferme
			si orientation de <<txt>> est égal à 2 alors lis
				case_lue = case_lue - tailleCote
			ferme
			si orientation de <<txt>> est égal à 3 alors lis
				case_lue = case_lue +1
			ferme
			block de <<txt>> = 0
			si x de <<txt>> est égal à ( 10 * tailleCote - 10 ) alors continuer = 0
		ferme
		texte de graff = "5/7-  " + "CREATION MURS... 1 /10"
		si DEBOGAGE est égal à 1 alors affiche "cinquième et sixième étape :
On crée maintenant d'autres cases vides dont le seul but est
de perturber l'utilisateur pour le détourner de la solution.
C'est le principe du labyrinthe. Pour cela, on va prendre une
case aléatoire :
- si elle est en contact avec une SEULE case vide, alors notre
case devient vide elle-aussi
- sinon, on ne fait rien avec cette case.
On s'assure ainsi de ne pas créer une deuxième solution à 
notre labyrinthe. Cette étape est celle prenant le plus de temps.
[LES NOUVELLES CASES VIDES SONT EN BLANC ]"
		continuer = 1
		tant que continuer est différent de 0, lis
			de 1 à ( 50 * tailleCote) , lis
				m = 0
				case_lue = tailleLabyrinthe
				mélange case_lue
				txt = [labyrinthe{ case_lue}]
				si x de <<txt>> est différent de ( 10 * tailleCote - 10 ) alors lis
					n = Case_lue + tailleCote
					txt2 = [labyrinthe{ n}]
					si block de <<txt2>> est égal à 0 alors m = m + 1
				ferme
				si y de <<txt>> est différent de 0 alors lis
					n = case_lue - 1
					txt2 = [labyrinthe{ n}]
					si block de <<txt2>> est égal à 0 alors m = m + 1
				ferme
				si x de <<txt>> est différent de 0 alors lis
					n = case_lue - tailleCote
					txt2 = [labyrinthe{ n}]
					si block de <<txt2>> est égal à 0 alors m = m + 1
				ferme
				si y de <<txt>> est différent de ( 10 * tailleCote - 10 ) alors lis
					n = case_lue + 1
					txt2 = [labyrinthe{ n}]
					si block de <<txt2>> est égal à 0 alors m = m + 1
				ferme
				si m est égal à 1 alors lis
					block de <<txt>> = 0
					si DEBOGAGE est égal à 1 alors couleur de <<txt>> = "blanc"
				ferme
			ferme
			continuer = continuer + 1
			pourcentage = 0
			de 0 à ( tailleLabyrinthe - 1 ), lis
				m = 0
				txt = [labyrinthe{ joker}]
				si x de <<txt>> est différent de ( 10 * tailleCote - 10 ) alors lis
					n = joker + tailleCote
					txt2 = [labyrinthe{ n}]
					si block de <<txt2>> est égal à 0 alors m = m + 1
				ferme
				si y de <<txt>> est différent de 0 alors lis
					n = joker - 1
					txt2 = [labyrinthe{ n}]
					si block de <<txt2>> est égal à 0 alors m = m + 1
				ferme
				si x de <<txt>> est différent de 0 alors lis
					n = joker - tailleCote
					txt2 = [labyrinthe{ n}]
					si block de <<txt2>> est égal à 0 alors m = m + 1
				ferme
				si y de <<txt>> est différent de ( 10 * tailleCote - 10 ) alors lis
					n = joker + 1
					txt2 = [labyrinthe{ n}]
					si block de <<txt2>> est égal à 0 alors m = m + 1
				ferme
				si m est égal à 1 alors lis
					si block de <<txt>> est égal à 1 alors lis
						pourcentage = pourcentage + 1
						si continuer est plus grand que 10 alors lis
							alea = 3
							mélange alea
							si alea est différent de 0 alors lis
								block de <<txt>> = 0
								si DEBOGAGE est égal à 1 alors couleur de <<txt>> = "sable"
							ferme
						ferme
					ferme
				ferme
			ferme
			si continuer est plus petit que 10 alors texte de graff = "5/7-  " + "CREATION MURS... " + continuer + " /10"
			sinon, texte de graff = "6/7-  " + pourcentage + " élements trouvés.."
			si pourcentage est plus petit que ( 6 ) alors continuer = 0
		ferme
		efface graff
		si DEBOGAGE est égal à 1 alors "le labyrinthe est maintenant fini !" !
		si DEBOGAGE est égal à 1 alors attends 1 seconde
		efface la toile
		projette fond
		de 0 à ( tailleLabyrinthe - 1), lis
			txt = [labyrinthe{ joker}]
			si block de <<txt>> est égal à 1 alors couleur de <<txt>> = "noir"
			si block de <<txt>> est égal à 0 alors couleur de <<txt>> = "blanc"
			si joker est égal à case_départ alors couleur de <<txt>> = "saumon"
			si joker est égal à case_arrivée alors couleur de <<txt>> = "saumon"
			si joker est égal à case_arrivée alors block de <<txt>> = 0
			projette <<txt>>
		ferme
		txt = [labyrinthe{ case_arrivée}]
		couleur de <<txt>> = "saumon"
		block de <<txt>> = 0
		continuer = 1
		case_lue = case_départ
		txt = [labyrinthe{ case_lue}]
		x de balle = x de <<txt>> + 5
		y de balle = y de <<txt>> + 5
		projette balle
		tant que continuer est égal à 1 , lis
			vide touch
			temporise
			touch = touche
			si touch est égal à "droite" alors lis
				si x de <<txt>> est différent de ( 10 * tailleCote - 10 ) alors lis
					n = case_lue + tailleCote
					txt2 = [labyrinthe{ n}]
					si block de <<txt2>> est égal à 0 alors lis
						case_lue = case_lue + tailleCote
						x de balle = x de balle + 10
					ferme
				ferme
			ferme
			si touch est égal à "haut" alors lis
				si y de <<txt>> est différent de 0 alors lis
					n = case_lue - 1
					txt2 = [labyrinthe{ n}]
					si block de <<txt2>> est égal à 0 alors lis
						case_lue = case_lue - 1
						y de balle = y de balle - 10
					ferme
				ferme
			ferme
			si touch est égal à "gauche" alors lis
				si x de <<txt>> est différent de 0 alors lis
					n = case_lue - tailleCote
					txt2 = [labyrinthe{ n}]
					si block de <<txt2>> est égal à 0 alors lis
						case_lue = case_lue - tailleCote
						x de balle = x de balle - 10
					ferme
				ferme
			ferme
			si touch est égal à "bas" alors lis
				si y de <<txt>> est différent de ( 10 * tailleCote - 10 ) alors lis
					n = case_lue + 1
					txt2 = [labyrinthe{ n}]
					si block de <<txt2>> est égal à 0 alors lis
						case_lue = case_lue + 1
						y de balle = y de balle + 10
					ferme
				ferme
			ferme
			txt = [labyrinthe{ case_lue}]
			si case_lue est égal à case_arrivée alors continuer = 0
		ferme
		efface la toile
		projette fond
		texte de graff = "BRAVO !"
		projette graff
		attends 1 seconde
		temporise
		temporise
		temporise
		temporise pendant 3 secondes
		termine

